<https://codeforces.com/contest/1872>

전체적으로 수학이 좀 많이 들어간 셋


## A

수학으로 해줘야하나 고민을 잠깐 해줬는데 a,b,c<=100을 보고 바로 구현으로 해결.

수학으로 풀면 $ceil(abs(a-b)/(2*c))$

## B

수학으로 해줘야 고민을 좀 오래했는데 이분탐색도 괜찮을 것 같아서 K에 대하여 이분탐색 돌려줌

## C

정해는 첨부터 끝까지 수학이였는데 많은 조건 분기로 해결

$r\le3$
이라면 무조건 안됨

$l\lt r$ 이라면 무조건 됨. (둘중 짝수에 대하여 나누기 2)

$l == r$ 이라면? 짝수면 되고 홀수면 조건을 따져줘야함

이때의 조건은 소수인지 아닌지에 대한 판별

다시 처음부터 정리해보자.

$l\le a+b\le r$ 이면서 $gcd(a,b)\ne1$ 이여야 한다.

$gcd(a,b) = g$ 라고 하면
```
a = g*x
b = g*y 
```
라고 할 수 있다.

$a+b==g*(x+y)$

$l\le a+b\le r$

$l\le g*(x+y)\le r$

이때 $l$과 $r$의 관계는 

$l==r$ and $l$은 홀수.

g가 1이 아닌 수이기 때문에 흔히 사용하는 인수를 판별하는 식을 사용하자.

```c++
for(int i=2;i*i<=l;i++) {
  if(i%g!=0) continue; //인수가 아닌 수 걸러내기

  int g = i;
  int xy = g/i;
  int x = 1;
  int y = xy-1;
  cout << x << " " << y << endl;
  return;
}
//만약 위 식에서 x, y가 판별되지 않았을 경우
cout << -1 << endl;
```

전체적인 시간복잡도는 $O(\sqrt N)$

## D

아주아주 약간 포함배제 냄새가 나는 문제. 느낌만 그렇고 실질적인 풀이는 gcd 이용

어떤 순열에서 x의 배수 index만큼 더하고 y의 배수 index 만큼 빼준다.

그렇다면 x의 배수, y의 배수, xy공배수를 나눠서 생각하자.

x의 배수는 가장 큰 값들로만 이루게.
y의 배수는 가장 작은 값들로만 이루게.
xy공배수는 상쇄되기 때문에 무시.

x의 배수가 a개, y의 배수가 b개, xy공배수가 c개라고 한다면

가장 큰 a-c개

가장 작은 b-c개

값을 계산하면 된다.

## E

xor의 특성은 잘 아는가를 묻는 문제 (xor문제는 대체로 누적합을 이용하는 문제가 잘나옴)

xor은 같은 값이면 0, 다른 값이면 1을 리턴한다.

세그먼트 트리를 아는 사람이라면 맨 처음 레이지 세그를 떠올렸을 것이다.

[xor](https://www.acmicpc.net/problem/14245) 문제와 상당히 닮아있다.

하지만 $2 g$ operation 에 대하여 구간값을 묻는 것이 아니라 전체 배열의 xor값을 묻는 것에 유의하자

$$ a \oplus a == 0$$

$$ a \oplus b == c$$

$$ c \oplus b == a$$

인 xor 특성을 사용해보자.

$1~N$까지의 xor operation 에 대한 누적합을 진행해보자. (prefix 배열)
또한 0, 1에 대한 xor 값을 찾기 위하여 a[i]==0 인 a[i]애 대한 xor 값을 보자. (int total)
a[i]==1 에 대한 값은 prefix[N] ^ total 를 하면 바로 나올 것이다.

```c++
int a[N+1] {}; //입력 배열
int prefix[N+1] {}; //누적합 배열
int total=0;
for(int i=1;i<=N;i++) {
    prefix[i] = prefix[i-1] ^ a[i];
    if(a[i]==1) continue;
    total ^= a[i];
}
```

$1 l r$ 연산에 대하여 직접 일일이 연산을 할 필요가 없다. 

하면 시간초과가 날 것을 계산을 통하여 알 수 있다.

$l~r$에 대하여 a[i]==1 인 값에 대한 xor값을 구하고 ( $O(1)$ ) 이 값을 $g $\oplus$ val$ 을 해주면 된다.

(부가설명추가좀해주세요)

$2\ g$ 연산에 대한 값은 $g==1$일 때 $prefix[N] ^ total$, $g==0$일 때 $total$ 을 출력해주면 된다.

## F 

위상정렬 문제.

문제의 그래프는 사이클이 있지만 functional graph인 점을 생각하고 보자.

항상 a->b로 가는 간선이 있다고 할 시에 반드시 a를 먼저 파는 것이 유리하다.

또한 사이클 내부로 진입하게 된다면 가장 가격이 싼 정점이 맨 마지막에 처리되어야 함을 알 수 있다.

위상정렬로 사이클 이전의 간선은 처리하고 사이클 내부에서 정점들의 합을 구하고 곱하기 2를 한 이후에 가격이 가장 싼 정점을 빼주면 된다.

## G (저도 못 풀어서 딴 사람들 도움으로 힌트 얻어서 업솔빙했음)

[sum=product](https://www.acmicpc.net/problem/28704) 과 상당히 비슷한 문제. (발상 및 구현 난이도는 G가 훨씬 쉬움)

곱셈을 하면 값이 지수적으로 증가함을 생각하자. 

대충 생각해봤을 때 sum(a[i]) 와 product(a[i]) 의 값은 정말로 많이 차이난다.

곱을 해주면 값이 반드시 지수적으로 증가하기 때문에 만약 2 이상의 값이 30개정도만 있어도 2^30을 넘게 된다. 

이렇게 된다면 모든 2 이상의 값들을 포함하는 것이 가장 유리하기 때문에 왼쪽에서 1이 아닌 값, 오른쪽에서 1이 아닌 값을 찾고 그 두 개의 index를 출력한다.

만약 그렇지 않다라고 한다면 2 이상의 값이 30개가 이하인 것들이다.

그러한 값들 중 2개를 선택하여 그 값이 문제에서 원하는 $l,r$ 값이 되도록 하자. 

$l,r$은 $a[l], a[r]$ 이 1이 아닌 수가 와야 최적임은 자명하다.

그렇다면 $_nC_2$ 과 같은 양상이 되는데 이때 $n$ 값은 30이하인 매우 작은 수이기 때문에 브루트포스를 하면 된다.


1. 맨 왼쪽 1이 아닌 값, 맨 오른쪽 1이 아닌 값을 출력하는가
2. $_nC_2$를 브루트포스를 하는가

에 대한 배경에는 $2^{30}$이라고 잡았는데 적당히 큰 수면 된다. (저는 1e9)
