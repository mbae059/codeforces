## <https://codeforces.com/contest/1864>

## A

Y부터 1,2,3씩 빼주자.
X까지 왔을때 괜찮은지 안 괜찮은지 출력


## B

기우성을 판단하는 것이 중요.

index의 기우성이 같으면 서로 얼마든지 바꿀 수 있음.

K의 역할은 그 기우성을 같게 만들어 줄 수도 있음.

만약 K가 홀수라면 기우성과 관련없이 마음대로 싹 다 바꿀 수 있음.

K가 짝수라면 기우성을 바꿀 수 없음.

## C

모든 수는 이진수로 나타낼 수 있음을 생각하자.

63을 나타내고 싶을 때 이를 이진수로 나타내보자.

11.111이 될 것이다.

1->2->4->8->....32. 이 때 32를 더해주면 63 초과가 되기 떄문에 16을 더해주고... 이런 식으로 하면 모든 수를 표현할 수 있다.

## D

dp + imos
```c++
pair<int,int> dp[N][N]; //imos를 위한 값. first 는 오른쪽에서 온 원뿔 값, second 는 왼쪽에서 온 원뿔 값.

int imos[N][N]; //invert를 몇번 했는가.
```

원뿔 형태로 펴저 나가고 하나의 블럭에 대하여 최대 한번만 operation을 수행하는 것이 효율적임은 자명하다. 또한 순서는 관계가 없기 때문에 순서를 강제하자.

i,j 에 대하여 operation을 수행한다면 i행에서는 자기자신만 영향을 받고 i-1행부터는 영향을 받지 않는다.

이를 통해 만약 matrix[i][j]=='1' && imos[i][j]%2==0 이거나 matrix[i][j]=='0' && imos[i][j]%2==1 이라고 한다면 반드시 i,j에 대하여 operation을 수행해야만 한다.

일정 구간에 대하여 누적합을 진행해야 하기 때문에 imos 법을 적용해보자.

i,j에 operation을 수행한다면 i+1, j-1 에는 +1, i+1,j+2에는 -1을 더해야함을 알 수 있다.

이는 i+2행에서도 해야 하지만 만약 i행에서 그것을 행한다면 O(N^3)이 되기 떄문에 i+1행에서 할 수 있도록 작업을 미뤄야한다. (lazy 느낌)

dp[i][j]는 i-1,j+1에서 오는 원뿔과, i-1,j-1에서 오는 원뿔 두 가지에 대하여 영향을 받는다.

```c++
dp[i][j].first = dp[i-1][j+1].first;
dp[i][j].second = dp[i-1][j-11].second;

dp[i][1].first += dp[i-1][1].first;
```

dp[i][1]은 예외 처리를 해줘야함을 잊지 말자.
