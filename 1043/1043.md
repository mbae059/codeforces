### <https://codeforces.com/contest/1043>


## A. Elections

K에 대해서 이분탐색으로 돌림. 하지만 K 값 자체가 상당히 작기 때문에 naive하게 짜도 된다.

## B. 

Bruteforce. N=1000 을 통해 N^2풀이를 생각해봤고 k=1~N에 대해서 검사를 해주면 된다.

## C.

Greedy
i까지 왔을 때 최적의 해라고 생각해보자. ...ba가 된다면 ...b 까지는 소팅이 되어있을 것이니 b에서 한번, a에서 한번 뒤집으면 해결된다.

그런데 만약 

...baaaa라면? 맨 마지막 a에서 뒤집는 것이 좋을 것이다. 

...baaaaab라면? 이것은 첫 b에서 뒤집어주고 두번째 b전 단계인 a에서 뒤집어주면 될 것이다.

이를 코드로 구현하면 된다.

## D.

M개의 string에서 부분문자열이 같은게 몇개인지를 구하는 문제.

부분문자열의 길이가 1인 것은 N개가 있는 것은 자명하다.

그렇다면 길이가 2 이상인 것들은 어떻게 해결할 지 잘 생각해보자.

이것또한 약간의 생각을 한다면 nC2 임을 알 수 있다.

부분문자열의 길이가 2이상인 것들을 구해주는 방법을 생각해보자

하나의 문자열에 대해서 각각의 str[i], str[i+1]을 간선이라고 생각해주고 그것을 M개의 string 에 대해서 카운팅해주자.

예를 들어 abcd 라고 한다면 a->b->c->d 로 가는 것이다.

만일 a->b 로 가는 것이 M개가 있다면 그러한 부분문자열은 공통적으로 존재할 것이다.

이제 정점 u,v에 대해서 u->v 로 가는 단방향 간선을 형성하는 그래프를 만들 수 있다.

indegree가 0이면서 outdegree가 1인 정점은 dag의 시작 부분일 것이다.

그 시작부분에 대해서 dfs를 해주고 깊이를 d라고 해준다면 dC2 값을 더해주면 된다.

## E. 못풀고 업솔빙으로 진행함.

우선 M을 제외했을 때의 값을 빨리 구할 수 있을까에 대한 질문에 먼저 답해야한다.

배열 a,b 를 i가 첫 번째 문제 풀때의 시간, 두 번째 문제 풀때의 시간이라고 한다면 min(a[i]+b[j], a[j]+b[i]) 이다.

즉 a[i]+b[j]<=a[j]+b[i] 일 때 선택하는 것은 a[i]+b[j]. 이런 부등식을 본다면 부등식을 예쁘게 만들어 주기 위해 이항을 하자.

a[i]-b[i]<=a[j]-b[j]. 즉 a[i]-b[j]를 기준으로 소팅을 해주면 된다.

입력으로 주어진 N개의 입력을 보자.
```
-1 3
2 4
1 1
3 5
2 2
```
이를 a[i]-b[i]를 기준으로 소팅해주면 다음과 같이 된다.
```
-1 3
2 4
3 5
1 1
2 2
```

이럴 때에 i에서의 값은 바로 구해줄 수 있다.
```c++
prefixA[i-1] + b[i] * (i-1) + a[i] * (N-i) + prefixB[N] - prefixB[i];
```
임을 알 수 있다.

여기까지의 시간복잡도는 sorting, prefix sum만 하였기 때문에 O(NlogN) 이 된다.
이제 M에 대해 고려를 해주자.

M은 값 2개가 들어왔을 때 해당하는 값만 빼주면 된다.
때문에 이는 간단히 구현할 수 있고 선형적으로 진행되기 때문에 총 시간복잡도는 O(NlogN + M) 이 된다.
