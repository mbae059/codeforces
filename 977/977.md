### <https://codeforces.com/contest/977>


## A. 

단순 구현

## B.

str[i], str[i+1]로 이루어진 string이 몇개 있는지 확인해주자

## C.

여러 방법이 있겠지만 map을 이용하여 갯수가 딱 K가 될 때의 값을 출력했다.

## D.

위상정렬을 이용해서 풀었다.

N=100인 것을 생각하고 각 a[i]가 정점이라고 생각한다면 a[i], a[j]의 관계를 O(N^2)으로 나타낼 수 있다.

inDegree[i]==0이면 시작점이기 때문에 dfs(i)를 해주면 된다.

## E.

딱봐도 dfs를 통해 푸는 건데 어떻게 구현을 해줘야 할지 상당히 막막해서 고민을 조금했다.

그런데도 생각이 안나서 DSU를 통해 각 사이클들을 하나로 묶어주고 DSU를 통해 묶여진 정점들의 차수가 2인지 확인해줬다.

## F.

LIS 냄새가 좀 많이 났지만 아니였다. 부분수열이 연속된 값을 가지게 하도록 하려면 어떻게 해야할까.

a[i]=3 일 때, i<j에 대하여 a[j]=4가 되는 j를 한번에 구할 수 있는 방법을 생각해보면 된다.

이는 map을 통해서 쉽게 구현할 수 있다 (map<int, queue<int>> mp). 입력을 받을 때에 mp[a[i]].push(i) 느낌으로 해주면 된다. 

그렇다면 a[i]=3 일 때, mp[a[i]+1].front()가 i보다 작으면 계속 pop해주고 크다면 idx = mp[a[i]+1].front() 리거 할 때 dp[idx] = max(dp[idx], dp[i]+1) 이 될 것이다.

(dp배열은 i번째로 끝나는 가장 큰 연속된 부분수열)

만약 a[i]가 적당히 작은 숫자였으면 O(N)으로 풀 수 있었을텐데 아쉽다.

예외처리에 상당히 주의를 요한다.

발상 자체는 5~10분 걸렸는데 예외처리 + 약간 이상하게 해서 30분 걸렸다.
